در ادامه، کل فایل services/api.ts که روی آن تکیه می‌کنیم را برای انتقال به تیم بک‌اند می‌فرستم؛ و سپس خلاصه منطق/انتظارات را می‌آورم تا کاملاً همسو شوید.

services/api.ts (کامل)

ts



// Real API client to connect frontend with backend endpointsconst API_BASE_URL = 'http://localhost:8889/api'const defaultHeaders: Record<string, string> = {  'Content-Type': 'application/json',  'Accept': 'application/json'}// Token & user helpersexport function saveToken(tokenData: { token: string; type: 'full'|'temporary'; user?: any }) {  localStorage.setItem('auth_token',   tokenData.token)  localStorage.setItem('token_type',   tokenData.type)  if (tokenData.user) {    localStorage.setItem('user_data',     JSON.stringify(tokenData.user))  }  if (typeof window !== 'undefined') {    window.dispatchEvent(new Event    ('auth:updated'))  }}export function getToken(): string | null { return localStorage.getItem('auth_token') }export function getTokenType(): string | null { return localStorage.getItem('token_type') }export function isLoggedIn(): boolean { return !!localStorage.getItem('auth_token') }export function logout() {  localStorage.removeItem('auth_token')  localStorage.removeItem('token_type')  localStorage.removeItem('user_data')  if (typeof window !== 'undefined') {    window.dispatchEvent(new Event    ('auth:updated'))  }}// Auth APIsexport async function sendOtpApi(phone: string): Promise<{ success: boolean; message?: string; expires_in?: number }>{  // از پراکسی نیترو استفاده می‌کنیم تا   مشکلات پاسخ نامعتبر مرورگر رفع شود  const res = await fetch(`/api/auth/  send-otp`, {    method: 'POST',    headers: defaultHeaders,    body: JSON.stringify({ phone })  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در ارسال کد')  return data}export async function verifyOtpApi(phone: string, code: string): Promise<{ token: string; isNewUser: boolean; user?: any; type?: 'full'|'temporary' }>{  // از پراکسی نیترو استفاده می‌کنیم تا   مشکلات پاسخ نامعتبر مرورگر رفع شود  const res = await fetch(`/api/auth/  verify-otp`, {    method: 'POST',    headers: defaultHeaders,    body: JSON.stringify({ phone, code })  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'کد نامعتبر است')  // تطبیق با پاسخ بک‌اند: ممکن است فیلد   type برگردد یا isNewUser  const type: 'full'|'temporary' = typeof   data.type === 'string'    ? (data.type === 'temporary' ?     'temporary' : 'full')    : (data.isNewUser ? 'temporary' :     'full')  saveToken({ token: data.token, type,   user: data.user })  return { ...data, isNewUser: data.  isNewUser ?? (type === 'temporary'),   type }}export async function completeProfileApi(payload: { name: string; nationalId: string; age: number }): Promise<{ token: string; user: any }>{  const token = getToken()  // بک‌اند انتظار دارد فیلد کدملی به   صورت national_id ارسال شود  const body = {    name: payload.name,    national_id: payload.nationalId,    age: payload.age  }  const res = await fetch(`$  {API_BASE_URL}/auth/complete-profile`, {    method: 'POST',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` },    body: JSON.stringify(body)  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در تکمیل پروفایل')  saveToken({ token: data.token, type:   'full', user: data.user })  return data}// User APIsexport async function getMe(): Promise<{ name: string; age: number; nationalId?: string; phone: string }>{  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/users/me`, {    method: 'GET',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` }  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در دریافت پروفایل')  return data}export async function updateMe(payload: Partial<{ name: string; age: number }>): Promise<{ name: string; age: number; national_id?: string; phone: string }>{  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/users/me`, {    method: 'PUT',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` },    body: JSON.stringify(payload)  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در به‌روزرسانی')  localStorage.setItem('user_data', JSON.  stringify(data))  return data}// Tests APIsexport async function uploadTest(imageFile: File, description: string, doctorId?: string): Promise<{ test_id: string; status: 'pending'|'processed'|'urgent'; result: any; is_urgent: boolean }>{  const token = getToken()  const form = new FormData()  form.append('image', imageFile)  form.append('description', description)  if (doctorId) form.append('doctor_id',   doctorId)  const res = await fetch(`$  {API_BASE_URL}/tests/upload`, {    method: 'POST',    headers: { 'Authorization': `Bearer $    {token}` },    body: form  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در آپلود تصویر')  return data}export async function listTests(): Promise<Array<{ id: string; date: string; status: 'pending'|'processed'|'urgent'; thumb: string }>>{  const token = getToken()  // Helper to map any backend list shape  const mapItems = (payload: any) => {    const arr = (payload?.tests ||     payload || [])    return (Array.isArray(arr) ? arr :     []).map((t: any) => ({      id: String(t.id),      date: t.created_at || t.      createdAt || '',      status: (t.status || 'processed')       as 'pending'|'processed'|'urgent',      thumb: t.image_path ? `/api/image?      url=${encodeURIComponent(`http://      localhost:8889/${t.image_path}`)}`       : 'https://via.placeholder.com/80'    }))  }  // Try doctor endpoint first (if user   is doctor)  const resDoctor = await fetch(`$  {API_BASE_URL}/tests/doctor`, {    method: 'GET',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` }  })  if (resDoctor.ok) {    const data = await resDoctor.json()    return mapItems(data)  }  // If forbidden or not doctor, fall   back to patient's own tests  if (resDoctor.status === 403 ||   resDoctor.status === 401 || resDoctor.  status === 404) {    const resPatient = await fetch(`$    {API_BASE_URL}/tests`, {      method: 'GET',      headers: { ...defaultHeaders,       'Authorization': `Bearer ${token}` }    })    const dataPatient = await resPatient.    json()    if (!resPatient.ok) throw new Error    (dataPatient.message || 'خطا در     دریافت تاریخچه تست‌ها')    return mapItems(dataPatient)  }  // Other errors from doctor endpoint  const dataErr = await resDoctor.json().  catch(() => ({}))  throw new Error((dataErr as any)?.  message || 'خطا در دریافت تست‌ها')}export async function getTest(id: string): Promise<{ id: string; image: string; aiResult: string; urgent: boolean }>{  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/tests/${id}`, {    method: 'GET',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` }  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در دریافت جزئیات')  return {    id: String(data.id),    image: data.image_path ? `/api/image?    url=${encodeURIComponent(`http://    localhost:8889/${data.image_path}`)}`     : 'https://via.placeholder.com/    400x300',    aiResult: typeof data.ai_result ===     'string'      ? data.ai_result      : (data.ai_result ? JSON.stringify      (data.ai_result) : (typeof data.      result === 'string' ? data.result :       JSON.stringify(data.result || ''))),    urgent: (data.status || '').    toLowerCase() === 'urgent'  }}// Admin APIsexport async function getAllUsers(): Promise<Array<{ id: string; name: string; role: 'patient'|'doctor'|'admin' }>>{  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/admin/users`, {    method: 'GET',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` }  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در دریافت کاربران')  return data.users || data}export async function changeUserRole(userId: string, newRole: 'patient'|'doctor'|'admin'){  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/admin/users/${userId}/  role`, {    method: 'PUT',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` },    body: JSON.stringify({ role:     newRole })  })  const data = await res.json()  if (!res.ok) throw new Error(data.  message || 'خطا در تغییر نقش')  return data.user || data}export async function deleteUser(userId: string){  const token = getToken()  const res = await fetch(`$  {API_BASE_URL}/admin/users/${userId}`, {    method: 'DELETE',    headers: { ...defaultHeaders,     'Authorization': `Bearer ${token}` }  })  if (!res.ok) {    const data = await res.json().catch    (() => ({}))    throw new Error(data.message || 'خطا     در حذف کاربر')  }  return { success: true }}
خلاصه منطق و انتظارات برای تیم بک‌اند

پایه آدرس بک‌اند: http://localhost:8889/api. درخواست‌ها JSON با هدرهای Content-Type: application/json و Accept: application/json.
OTP ۴ رقمی است:
UI ورودی OTP را به ۴ رقم محدود می‌کند و قبل از فراخوانی، اگر طول !== 4 باشد خطای کاربر نشان داده می‌شود.
فرانت‌اند OTP را به‌صورت رشته‌ی اعداد انگلیسی ارسال می‌کند.
پراکسی داخلی برای OTP:
POST /api/auth/send-otp → پراکسی نیترو به بک‌اند /auth/send-otp روی پورت 8889. ورودی: { phone: string } (شماره به فرمت ۰۹xxxxxxxxx، فقط اعداد). خروجی موفق: { success: true, message?: string, expires_in?: number }. خطا: { message: string } با استاتوس غیر 2xx.
POST /api/auth/verify-otp → پراکسی نیترو به بک‌اند /auth/verify-otp. ورودی: { phone: string, code: string } که code باید ۴ رقمی باشد. خروجی موفق: { token: string, isNewUser?: boolean, type?: 'full'|'temporary', user?: object }. اگر type یا isNewUser وجود نداشته باشد، فرانت‌اند به‌صورت محافظه‌کارانه تصمیم می‌گیرد (کاربر جدید → temporary).
توکن و وضعیت کاربر:
در موفقیت verify، فرانت‌اند token را در localStorage ذخیره می‌کند و رویداد auth:updated منتشر می‌کند. type می‌تواند 'full'|'temporary' باشد؛ اگر مشخص نباشد، از isNewUser نتیجه‌گیری می‌شود.
تکمیل پروفایل:
POST /auth/complete-profile با هدر Authorization: Bearer <token> و بدنه { name, national_id, age }. خروجی موفق: { token, user } و نوع توکن به 'full' تنظیم می‌شود.
مدیریت کاربر:
GET /users/me خروجی: پروفایل فعلی.
PUT /users/me بدنه جزئی { name?, age? }، خروجی: پروفایل به‌روز.
تست‌ها:
POST /tests/upload با FormData شامل image, description, doctor_id?. خروجی: { test_id, status, result, is_urgent }.
GET /tests/doctor برای پزشک؛ در صورت 403/401/404، فرانت‌اند به GET /tests کاربر بازگشت می‌کند.
GET /tests/:id خروجی نرمال‌سازی می‌شود تا همیشه شامل { id, image, aiResult, urgent } باشد.
تصاویر با پراکسی داخلی فرانت‌اند سرو می‌شوند: image_path به /api/image?url=<backend file url> تبدیل می‌شود تا مشکلات CORS/فرمت پاسخ رفع شود.
ادمین:
GET /admin/users، PUT /admin/users/:id/role با { role }، DELETE /admin/users/:id.
خطاها:
اگر res.ok نباشد، فرانت‌اند از فیلد message JSON برای نشان دادن خطا استفاده می‌کند. لطفاً در خطاها همیشه { message: string } برگردانید.
اگر لازم می‌دانید من در verifyOtpApi هم یک گارد نرم اضافه کنم که در صورت code.length !== 4 قبل از ارسال، خطا بدهد تا از ارسال کدهای نامعتبر جلوگیری شود، انجام می‌دهم. فعلاً در کامپوننت انجام شده و مسیرهای پراکسی OTP با نیترو فعال است.